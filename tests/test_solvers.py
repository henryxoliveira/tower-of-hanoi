"""
Tests for Tower of Hanoi solvers.

This module contains comprehensive tests for the solving algorithms in hanoi.solvers.
The tests verify that the recursive solver produces correct, optimal solutions
for the Tower of Hanoi puzzle across various input sizes and configurations.

Test Coverage:
- Move count validation (2^n - 1 optimal moves)
- Solution correctness (puzzle is actually solved)
- Move legality (all moves follow game rules)
- Known solution sequences (specific test cases)
- Different peg configurations (flexibility testing)
"""

import pytest
from hanoi.solvers import hanoi_recursive
from hanoi.rules import initial_state, apply_move, is_solved

# =============================================================================
# MOVE COUNT VALIDATION TESTS
# =============================================================================

def test_hanoi_recursive_move_count():
    """
    Test that recursive solver produces correct number of moves.
    
    This test verifies that the recursive solver generates the optimal number
    of moves for the Tower of Hanoi puzzle. The optimal solution requires
    exactly 2^n - 1 moves for n disks, which is a well-known mathematical
    property of the puzzle.
    
    The test covers multiple disk counts to ensure the algorithm works
    correctly across different puzzle sizes.
    """
    for n in range(1, 7):  # Test n=1 to n=6
        moves = list(hanoi_recursive(n))
        expected_moves = 2**n - 1  # Mathematical formula for optimal moves
        assert len(moves) == expected_moves, f"n={n}: expected {expected_moves}, got {len(moves)}"

# =============================================================================
# SOLUTION CORRECTNESS TESTS
# =============================================================================

def test_hanoi_recursive_solves_puzzle():
    """
    Test that applying all moves from recursive solver solves the puzzle.
    
    This test verifies that the recursive solver actually produces a valid
    solution by applying all generated moves to the initial state and
    checking that the resulting state is solved. This is the most important
    test as it validates the core functionality of the solver.
    
    The test covers multiple disk counts to ensure the solver works
    correctly for different puzzle sizes.
    """
    for n in range(1, 7):  # Test n=1 to n=6
        # Start with initial state
        state = initial_state(n)
        moves = list(hanoi_recursive(n))
        
        # Apply all moves in sequence
        for move in moves:
            state = apply_move(state, move)
        
        # Verify that the puzzle is solved after applying all moves
        assert is_solved(state, n), f"Puzzle not solved for n={n}"

# =============================================================================
# MOVE LEGALITY TESTS
# =============================================================================

def test_hanoi_recursive_moves_are_legal():
    """
    Test that all moves from recursive solver are legal.
    
    This test verifies that every move generated by the recursive solver
    follows the Tower of Hanoi rules. It applies each move individually
    and checks that it's legal before applying it to the game state.
    
    This ensures that the solver doesn't generate invalid moves that
    would violate the game rules (e.g., placing larger disk on smaller).
    """
    for n in range(1, 6):  # Test n=1 to n=5 (n=6 might be slow)
        state = initial_state(n)
        moves = list(hanoi_recursive(n))
        
        for i, move in enumerate(moves):
            # Verify each move is legal before applying it
            from hanoi.rules import is_legal_move
            assert is_legal_move(state, move), f"Illegal move {i}: {move}"
            
            # Apply the move to update the state for next iteration
            state = apply_move(state, move)

# =============================================================================
# KNOWN SOLUTION SEQUENCE TESTS
# =============================================================================

def test_hanoi_recursive_specific_sequence():
    """
    Test specific known sequence for n=3.
    
    This test verifies that the recursive solver produces the exact
    known optimal sequence for the 3-disk Tower of Hanoi puzzle.
    This is a well-known solution that can be verified manually,
    making it a reliable test case for algorithm correctness.
    
    The 3-disk solution is:
    1. Move disk 1 (smallest) from A to C
    2. Move disk 2 (medium) from A to B
    3. Move disk 1 from C to B
    4. Move disk 3 (largest) from A to C
    5. Move disk 1 from B to A
    6. Move disk 2 from B to C
    7. Move disk 1 from A to C
    """
    moves = list(hanoi_recursive(3))
    
    # Define the known optimal solution for n=3
    expected_moves = [
        {"from_": 0, "to": 2},  # Move disk 1 to C
        {"from_": 0, "to": 1},  # Move disk 2 to B
        {"from_": 2, "to": 1},  # Move disk 1 to B
        {"from_": 0, "to": 2},  # Move disk 3 to C
        {"from_": 1, "to": 0},  # Move disk 1 to A
        {"from_": 1, "to": 2},  # Move disk 2 to C
        {"from_": 0, "to": 2},  # Move disk 1 to C
    ]
    
    # Verify the number of moves matches
    assert len(moves) == len(expected_moves)
    
    # Verify each move matches the expected sequence
    for actual, expected in zip(moves, expected_moves):
        assert actual["from_"] == expected["from_"]
        assert actual["to"] == expected["to"]

# =============================================================================
# CONFIGURATION FLEXIBILITY TESTS
# =============================================================================

def test_hanoi_recursive_different_pegs():
    """
    Test recursive solver with different peg configurations.
    
    This test verifies that the recursive solver works correctly when
    the source, destination, and auxiliary pegs are configured differently
    from the default (A->C with B as auxiliary). This tests the flexibility
    of the algorithm and ensures it works for any valid peg configuration.
    
    The test uses a non-standard configuration: moving from peg 1 to peg 0
    with peg 2 as auxiliary, and verifies that the solution is still valid.
    """
    # Test moving from peg 1 to peg 0 with auxiliary peg 2
    moves = list(hanoi_recursive(3, a=1, b=0, c=2))
    
    # Should still produce the optimal number of moves (2^3 - 1 = 7)
    assert len(moves) == 7
    
    # Create initial state with disks on peg 1 instead of peg 0
    state = ([], [{"id": 0, "size": 3}, {"id": 1, "size": 2}, {"id": 2, "size": 1}], [])
    
    # Apply all moves to verify they work with this configuration
    for move in moves:
        state = apply_move(state, move)
    
    # Verify that all disks end up on the target peg (peg 0)
    assert len(state[0]) == 3  # All disks on target peg
    assert len(state[1]) == 0  # Source peg empty
    assert len(state[2]) == 0  # Auxiliary peg empty
